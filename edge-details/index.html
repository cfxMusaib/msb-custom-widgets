<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nodes with Multiple Edges and Interfaces</title>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <script>
        // =============================================================================
        // CONFIGURATION - Modify these settings as needed
        // =============================================================================
        
        // Set to false when using real API data, true for testing with sample data
        const TEST_MODE = true;
        
        // Map relationship properties to edge labels
        // Use lodash path syntax for nested properties: "displayAttributes[0].value"
        const attributeMap = {
            "nodeLabel": "node_label",
            "nodeIcon": "node_type",
            "edgeMiddleLabel": "link_type",
            "edgeLeftLabel": "displayAttributes[0].value",
            "edgeRightLabel": "displayAttributes[1].value"
        }
        
        // =============================================================================
        // END CONFIGURATION
        // =============================================================================
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            width: 100%;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            overflow: hidden;
            height: 100%;
            width: 100%;
        }

        .container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .graph-container {
            width: 100%;
            height: 100%;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;

            overflow-x: auto;
        }

        .node {
            height: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
            min-width: 80px;
        }

        .node-circle {
            width: 60px;
            height: 60px;
            background-color: #e3f2fd;
            border: 2px solid #1976d2;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            padding: 10px;
        }

        .node-circle img {
            height: 100%;
            width: 100%;
        }

        .node-label {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            margin-top: 8px;
            text-align: center;

            width: 150px;
        }

        .edges-container {
            display: flex;
            align-items: stretch;
            flex: 1;
            margin: 0 20px;

            min-width: 300px;
        }

        .parallel-line {
            width: 4px;
            background-color: #1976d2;
            border-radius: 2px;
            flex-shrink: 0;
        }

        .edges {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            flex: 1;
            margin: 0 10px;
            min-width: 0;
        }

        .edge {
            display: flex;
            align-items: center;
            position: relative;
            height: 40px;
            margin: 5px 0;
        }

        .edge-line {
            flex: 1;
            height: 2px;
            background-color: #666;
            position: relative;
            margin-right: 8px;
            min-width: 0;
        }

        .edge.dotted .edge-line {
            background: repeating-linear-gradient(
                to right,
                #666 0px,
                #666 8px,
                transparent 8px,
                transparent 16px
            );
        }

        .edge:hover .edge-line {
            background-color: #1976d2;
            height: 3px;
        }

        .edge.dotted:hover .edge-line {
            background: repeating-linear-gradient(
                to right,
                #1976d2 0px,
                #1976d2 8px,
                transparent 8px,
                transparent 16px
            );
        }

        .edge:hover {
            transform: scaleY(1.1);
        }

        .arrow {
            width: 0;
            height: 0;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
        }

        .arrow.right {
            border-left: 8px solid #666;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            right: -2px;
        }

        .arrow.left {
            border-right: 8px solid #666;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            left: -2px;
        }

        .edge:hover .arrow.right {
            border-left-color: #1976d2;
            border-left-width: 10px;
            border-top-width: 7px;
            border-bottom-width: 7px;
        }

        .edge:hover .arrow.left {
            border-right-color: #1976d2;
            border-right-width: 10px;
            border-top-width: 7px;
            border-bottom-width: 7px;
        }

        .edge-label {
            position: absolute;
            top: -2px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #333;
            white-space: nowrap;
        }

        .interface-label {
            position: absolute;
            background-color: #e3f2fd;
            padding: 2px 6px;
            border: 1px solid #1976d2;
            border-radius: 4px;
            font-size: 10px;
            color: #1976d2;
            white-space: nowrap;
            font-weight: 500;

            /* width */
            max-width: 120px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

        .interface-label.source {
            left: 10px;
            top: -4px;
        }

        .interface-label.dest {
            right: 20px;
            top: -4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="graph-container" id="graph-container">
            <!-- Edges Container -->
            <div class="edges-container">
                <!-- Left Parallel Line -->
                <div class="parallel-line" id="left-line"></div>

                <!-- Edges -->
                <div class="edges" id="edges">
                    <!-- Edges will be dynamically added here -->
                </div>

                <!-- Right Parallel Line -->
                <div class="parallel-line" id="right-line"></div>
            </div>
        </div>
    </div>

    <script id="context-data" type="application/json">
        {{ all_variables.get("context") | tojson }}
    </script>

    <script>

        // Sample data based on your structure
        const data = {
            components: [
                { node_label: 'linux-mysql-db01', node_id: 'left-node' },
                { node_label: 'win2012-dynatrace-template-dnd', node_id: 'right-node' }
            ],
            relationships: [
                { 
                    id: '1', 
                    left_id: 'left-node', 
                    right_id: 'right-node', 
                    relation_type: 'Edge Label 1', 
                    link_type: "OSPF",
                    displayAttributes: [
                        {
                            "attribute": "source_interface_name",
                            "value": "ethernet_port"
                        },
                        {
                            "attribute": "dest_interface_name",
                            "value": "ethernet_port"
                        }
                    ],
                    dotted: false
                },
                { 
                    id: '2', 
                    left_id: 'right-node', 
                    right_id: 'left-node', 
                    relation_type: 'Edge Label 2',
                    link_type: "CDP",
                    displayAttributes: [
                        {
                            "attribute": "source_interface_name",
                            "value": "ethernet_port"
                        },
                        {
                            "attribute": "dest_interface_name",
                            "value": "ethernet_port"
                        }
                    ],
                    dotted: true
                },
                { 
                    id: '3', 
                    left_id: 'left-node', 
                    right_id: 'right-node', 
                    relation_type: 'Edge Label 3', 
                    link_type: "BGP",
                    displayAttributes: [
                        {
                            "attribute": "source_interface_name",
                            "value": "serial_port"
                        },
                        {
                            "attribute": "dest_interface_name",
                            "value": "serial_port"
                        }
                    ],
                    dotted: false
                },
                { 
                    id: '4', 
                    left_id: 'right-node', 
                    right_id: 'left-node', 
                    relation_type: 'Edge Label 4', 
                    link_type: "LLDP",
                    displayAttributes: [
                        {
                            "attribute": "source_interface_name",
                            "value": "ethernet_port"
                        },
                        {
                            "attribute": "dest_interface_name",
                            "value": "ethernet_port"
                        }
                    ],
                    dotted: true
                }
            ]
        };

        // get context from jinja all_variables (parsed from JSON script tag)
        const context = (() => {
            const el = document.getElementById("context-data");
            if (!el) return null;
            try { return JSON.parse(el.textContent || "null"); } catch { return null; }
        })();
        let left_id, right_id;
        
        // Get icon map from parent window
        const iconMap = window.parent?.cfxIconMap || {};
        console.log("MSB context", context)
        console.log("MSB iconMap from parent", iconMap)

        const setContextToApiEndpoint = (api_endpoint) => {
            if(!context){
                throw new Error("No context found");
            }
            left_id = context?.displayAttributes?.find(attr => attr.key === "left_id")?.value;
            right_id = context?.displayAttributes?.find(attr => attr.key === "right_id")?.value;

            if(!left_id || !right_id){
                throw new Error("No left or right id found");
            }
            api_endpoint.serviceRequestDescriptor.params.params[0].context = context;
            api_endpoint.serviceRequestDescriptor.params.params[0].context.node_list = [
                {
                    "node_id": left_id
                },
                {
                    "node_id": right_id
                }
            ]
            api_endpoint.serviceRequestDescriptor.params.params[0].stack_type = "dynamic";
            api_endpoint.serviceRequestDescriptor.params.params[0].stack_definition = api_endpoint.serviceRequestDescriptor.params.params[0].context.stack_definition;
            if(api_endpoint.serviceRequestDescriptor.params.params[0].context.name){
                delete api_endpoint.serviceRequestDescriptor.params.params[0].context.name;
            }
        }
        async function fetchData() {
            const api_url = "/api/portal/rdac/browseapi";
            const api_endpoint = {
                serviceRequestDescriptor: {
                    "serviceName": "saas-reports",
                    "version": "*",
                    "params": {
                    "params": [
                        {
                            "dashboardId": "Topology",
                            "reportId": "rda.saas.stack.view.topo"
                        }
                    ]
                    },
                    "methodName": "getReport",
                    "ignoreCall": true,
                    "parseOutput": true
                }
            };
            setContextToApiEndpoint(api_endpoint);
            try {
                console.log("MSB Making request to", api_url, api_endpoint)
                const response = await fetch(api_url, {
                method: "POST",
                body: JSON.stringify(api_endpoint),
                headers: {
                    "Content-Type": "application/json",
                },
                });
                const data = await response.json();
                return data.serviceResult?.data?.dataFlowGraph;
            } catch (error) {
                console.error("Fetch error:", error);
                appendErrorText("Failed to fetch data");
            }
        }

        // Create nodes
        function createNodes(components) {
            const container = document.getElementById('graph-container');
            
            // Clear existing nodes
            const existingNodes = container.querySelectorAll('.node');
            existingNodes.forEach(node => node.remove());
            
            // Get first 2 components
            const leftNode = components[0];
            const rightNode = components[1];
            
            if (!leftNode || !rightNode) {
                console.error('Need at least 2 components to create nodes');
                return;
            }
            
            // Create left node
            const leftNodeDiv = document.createElement('div');
            leftNodeDiv.className = 'node';
            leftNodeDiv.id = 'node-a';
            const leftNodeLabel = _.get(leftNode, attributeMap.nodeLabel) || 'Node A';
            const leftNodeIcon = _.get(leftNode, attributeMap.nodeIcon, '');

            let leftNodeIconSrc;
            if(leftNodeIcon?.startsWith('http')){
                leftNodeIconSrc = leftNodeIcon;
            }else {
                leftNodeIconSrc = iconMap[leftNodeIcon] ? "/" + iconMap[leftNodeIcon] : '/assets/img/blueprints/canvas/empty_icon.png';
            }
            leftNodeDiv.innerHTML = `
                <div class="node-circle">
                    <img src="${leftNodeIconSrc}" />
                </div>
                <div class="node-label">${leftNodeLabel}</div>
            `;
            container.insertBefore(leftNodeDiv, container.querySelector('.edges-container'));
            
            // Create right node
            const rightNodeDiv = document.createElement('div');
            rightNodeDiv.className = 'node';
            rightNodeDiv.id = 'node-b';
            const rightNodeLabel = _.get(rightNode, attributeMap.nodeLabel) || 'Node B';
            const rightNodeIcon = _.get(rightNode, attributeMap.nodeIcon, '');
            let rightNodeIconSrc;
            if(rightNodeIcon?.startsWith('http')){
                rightNodeIconSrc = rightNodeIcon;
            }else {
                rightNodeIconSrc = iconMap[rightNodeIcon] ? "/" + iconMap[rightNodeIcon] : '/assets/img/blueprints/canvas/empty_icon.png';
            }
            rightNodeDiv.innerHTML = `
                <div class="node-circle">
                    <img src="${rightNodeIconSrc}" />
                </div>
                <div class="node-label">${rightNodeLabel}</div>
            `;
            container.appendChild(rightNodeDiv);
        }

        // Create edges
        function createEdges(relationships) {
            const edgesContainer = document.getElementById('edges');
            
            relationships.forEach((relationship) => {
                // Create edge container
                const edgeDiv = document.createElement('div');
                edgeDiv.className = 'edge';
                if (relationship.dotted) {
                    edgeDiv.classList.add('dotted');
                }

                // Create edge line
                const edgeLine = document.createElement('div');
                edgeLine.className = 'edge-line';

                // Create arrow - determine direction based on right_id
                const arrow = document.createElement('div');
                const isRightToLeft = relationship.right_id === 'left-node';
                arrow.className = `arrow ${isRightToLeft ? 'left' : 'right'}`;

                // Create edge label
                const edgeLabel = document.createElement('div');
                edgeLabel.className = 'edge-label';
                edgeLabel.textContent = _.get(relationship, attributeMap.edgeMiddleLabel) || '';

                // Create source interface label
                let sourceInterfaceLabel;
                const leftLabelValue = _.get(relationship, attributeMap.edgeLeftLabel);
                if(leftLabelValue){
                    sourceInterfaceLabel = document.createElement('p');
                    sourceInterfaceLabel.title = leftLabelValue;
                    sourceInterfaceLabel.className = 'interface-label source';
                    sourceInterfaceLabel.textContent = leftLabelValue;
                }

                // Create destination interface label
                let destInterfaceLabel;
                const rightLabelValue = _.get(relationship, attributeMap.edgeRightLabel);
                if(rightLabelValue){
                    destInterfaceLabel = document.createElement('p');
                    destInterfaceLabel.title = rightLabelValue;
                    destInterfaceLabel.className = 'interface-label dest';
                    destInterfaceLabel.textContent = rightLabelValue;
                }
                // Assemble edge
                edgeLine.appendChild(arrow);
                edgeDiv.appendChild(edgeLine);
                edgeDiv.appendChild(edgeLabel);
                if(sourceInterfaceLabel){
                    edgeDiv.appendChild(sourceInterfaceLabel);
                }
                if(destInterfaceLabel){
                    edgeDiv.appendChild(destInterfaceLabel);
                }
                edgesContainer.appendChild(edgeDiv);
            });
        }


        // Initialize the graph
        async function init() {
            if(TEST_MODE){
                createNodes(data.components);
                createEdges(data.relationships);
                return;
            }
            try {
                const data = await fetchData();
                const relationships = data?.relationships;
                const components = data?.components;

                if (!relationships || relationships?.length === 0) {
                    throw new Error("No data to display");
                    return;
                }

                const leftNode = components.find(component => component.id === left_id);
                const rightNode = components.find(component => component.id === right_id);

                // filter out edges/relationships
                const filteredRelationships = relationships.filter(relationship => {
                    return (relationship.left_id === left_id &&
                    relationship.right_id === right_id)
                })

                createNodes(components);
                createEdges(filteredRelationships);

                console.log("MSB data", filteredRelationships, leftNode, rightNode)
            } catch (error) {
                console.error("Fetch error:", error);
            }
        }

        // Start the application
        init();
    </script>
</body>
</html>