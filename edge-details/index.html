<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nodes with Multiple Edges and Interfaces</title>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <script>
        // =============================================================================
        // CONFIGURATION - Modify these settings as needed
        // =============================================================================
        
        // Set to false when using real API data, true for testing with sample data
        const TEST_MODE = false;
        
        // Map relationship properties to edge labels
        // Use lodash path syntax for nested properties: "displayAttributes[0].value"
        const attributeMap = {
            "nodeLabel": "node_label",
            "nodeIcon": "node_type",
            "edgeCenterLabel": "link_type",
            "edgeSourceLabel": "source_interface_name",
            "edgeDestLabel": "dest_interface_name"
        }
        
        // =============================================================================
        // END CONFIGURATION
        // =============================================================================
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            width: 100%;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            overflow: hidden;
            height: 100%;
            width: 100%;
        }

        .container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .graph-container {
            width: 100%;
            height: 100%;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;

            overflow-x: auto;
        }

        .node {
            height: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
            min-width: 80px;
        }

        .node-circle {
            width: 60px;
            height: 60px;
            background-color: #e3f2fd;
            border: 2px solid #1976d2;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            padding: 10px;
        }

        .node-circle img {
            height: 100%;
            width: 100%;
        }

        .node-label {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            margin-top: 8px;
            text-align: center;

            width: 150px;
            height: 40px;
            word-break: break-word;
        }

        .edges-container {
            display: flex;
            align-items: stretch;
            flex: 1;
            margin: 0 20px;

            min-width: 300px;
        }

        .parallel-line {
            width: 4px;
            background-color: #1976d2;
            border-radius: 2px;
            flex-shrink: 0;
        }

        .edges {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            flex: 1;
            margin: 0 10px;
            min-width: 0;
        }

        .edge {
            display: flex;
            align-items: center;
            position: relative;
            height: 40px;
            margin: 5px 0;
        }

        .edge-line {
            flex: 1;
            height: 2px;
            background-color: #666;
            position: relative;
            margin-right: 8px;
            min-width: 0;
        }

        .edge.dotted .edge-line {
            background: repeating-linear-gradient(
                to right,
                #666 0px,
                #666 8px,
                transparent 8px,
                transparent 16px
            );
        }

        .edge:hover .edge-line {
            background-color: #1976d2;
            height: 3px;
        }

        .edge.dotted:hover .edge-line {
            background: repeating-linear-gradient(
                to right,
                #1976d2 0px,
                #1976d2 8px,
                transparent 8px,
                transparent 16px
            );
        }

        .edge:hover {
            transform: scaleY(1.1);
        }

        .arrow {
            width: 0;
            height: 0;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
        }

        .arrow.right {
            border-left: 8px solid #666;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            right: -2px;
        }

        .arrow.left {
            border-right: 8px solid #666;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            left: -2px;
        }

        .edge:hover .arrow.right {
            border-left-color: #1976d2;
            border-left-width: 10px;
            border-top-width: 7px;
            border-bottom-width: 7px;
        }

        .edge:hover .arrow.left {
            border-right-color: #1976d2;
            border-right-width: 10px;
            border-top-width: 7px;
            border-bottom-width: 7px;
        }

        .edge-label {
            position: absolute;
            top: -2px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #333;
            white-space: nowrap;
        }

        .interface-label {
            position: absolute;
            background-color: #e3f2fd;
            padding: 2px 6px;
            border: 1px solid #1976d2;
            border-radius: 4px;
            font-size: 10px;
            color: #1976d2;
            white-space: nowrap;
            font-weight: 500;

            /* width */
            max-width: 120px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

        .interface-label.left {
            left: 10px;
            top: -4px;
        }

        .interface-label.right {
            right: 20px;
            top: -4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="graph-container" id="graph-container">
            <!-- Edges Container -->
            <div class="edges-container">
                <!-- Left Parallel Line -->
                <div class="parallel-line" id="left-line"></div>

                <!-- Edges -->
                <div class="edges" id="edges">
                    <!-- Edges will be dynamically added here -->
                </div>

                <!-- Right Parallel Line -->
                <div class="parallel-line" id="right-line"></div>
            </div>
        </div>
    </div>

    <script id="context-data" type="application/json">
        {{ all_variables.get("context") | tojson }}
    </script>

    <script>
        // Sample data based on your structure
        const data = {
            components: [
                { node_label: 'linux-mysql-db01', node_id: 'left-node' },
                { node_label: 'win2012-dynatrace-template-dnd', node_id: 'right-node' }
            ],
            relationships: [
                { 
                    id: '1', 
                    left_id: 'left-node', 
                    right_id: 'right-node', 
                    relation_type: 'Edge Label 1', 
                    link_type: "OSPF",
                    displayAttributes: [
                        {
                            "key": "source_interface_name",
                            "value": "ethernet_port"
                        },
                        {
                            "key": "dest_interface_name",
                            "value": "ethernet_port"
                        }
                    ],
                    dotted: false
                },
                { 
                    id: '2', 
                    left_id: 'right-node', 
                    right_id: 'left-node', 
                    relation_type: 'Edge Label 2',
                    link_type: "CDP",
                    displayAttributes: [
                        {
                            "key": "source_interface_name",
                            "value": "serial_port"
                        },
                        {
                            "key": "dest_interface_name",
                            "value": "ethernet_port"
                        }
                    ],
                    dotted: true
                },
                { 
                    id: '3', 
                    left_id: 'left-node', 
                    right_id: 'right-node', 
                    relation_type: 'Edge Label 3', 
                    link_type: "BGP",
                    displayAttributes: [
                        {
                            "key": "source_interface_name",
                            "value": "serial_port"
                        },
                        {
                            "key": "dest_interface_name",
                            "value": "serial_port"
                        }
                    ],
                    dotted: false,
                    is_directionless: true
                },
                { 
                    id: '4', 
                    left_id: 'right-node', 
                    right_id: 'left-node', 
                    relation_type: 'Edge Label 4', 
                    link_type: "LLDP",
                    displayAttributes: [
                        {
                            "key": "source_interface_name",
                            "value": "ethernet_port"
                        },
                        {
                            "key": "dest_interface_name",
                            "value": "ethernet_port"
                        }
                    ],
                    dotted: true
                }
            ]
        };

        // get context from jinja all_variables (parsed from JSON script tag)
        const context = (() => {
            const el = document.getElementById("context-data");
            if (!el) return null;
            try { return JSON.parse(el.textContent || "null"); } catch { return null; }
        })();
        let LHSNodeId, RHSNodeId;
        
        // Get icon map from parent window
        const iconMap = window.parent?.cfxIconMap || {};
        console.log("MSB context", context)
        console.log("MSB iconMap from parent", iconMap)

        const setContextToApiEndpoint = (api_endpoint) => {
            if(!context){
                throw new Error("No context found");
            }
            LHSNodeId = context?.displayAttributes?.find(attr => attr.key === "left_id")?.value;
            RHSNodeId = context?.displayAttributes?.find(attr => attr.key === "right_id")?.value;

            if(!LHSNodeId || !RHSNodeId){
                throw new Error("No left or right id found");
            }
            api_endpoint.serviceRequestDescriptor.params.params[0].context = context;
            api_endpoint.serviceRequestDescriptor.params.params[0].context.node_list = [
                {
                    "node_id": LHSNodeId
                },
                {
                    "node_id": RHSNodeId
                }
            ]
            api_endpoint.serviceRequestDescriptor.params.params[0].stack_type = "dynamic";
            api_endpoint.serviceRequestDescriptor.params.params[0].stack_definition = api_endpoint.serviceRequestDescriptor.params.params[0].context.stack_definition;
            if(api_endpoint.serviceRequestDescriptor.params.params[0].context.name){
                delete api_endpoint.serviceRequestDescriptor.params.params[0].context.name;
            }
        }
        async function fetchData() {
            const api_url = "/api/portal/rdac/browseapi";
            const api_endpoint = {
                serviceRequestDescriptor: {
                    "serviceName": "saas-reports",
                    "version": "*",
                    "params": {
                    "params": [
                        {
                            "dashboardId": "Topology",
                            "reportId": "rda.saas.stack.view.topo"
                        }
                    ]
                    },
                    "methodName": "getReport",
                    "ignoreCall": true,
                    "parseOutput": true
                }
            };
            setContextToApiEndpoint(api_endpoint);
            try {
                console.log("MSB Making request to", api_url, api_endpoint)
                const response = await fetch(api_url, {
                method: "POST",
                body: JSON.stringify(api_endpoint),
                headers: {
                    "Content-Type": "application/json",
                },
                });
                const data = await response.json();
                return data.serviceResult?.data?.dataFlowGraph;
            } catch (error) {
                console.error("Fetch error:", error);
                appendErrorText("Failed to fetch data");
            }
        }

        // Create nodes
        function createNodes(components) {
            const container = document.getElementById('graph-container');
            
            // Clear existing nodes
            const existingNodes = container.querySelectorAll('.node');
            existingNodes.forEach(node => node.remove());
            
            // Find LHS and RHS nodes by their IDs
            const lhsNode = components.find(component => component.node_id === LHSNodeId);
            const rhsNode = components.find(component => component.node_id === RHSNodeId);

            if (!lhsNode || !rhsNode) {
                console.error('LHS or RHS node not found in components');
                return;
            }
            
            // Create left node (LHS)
            const leftNodeDiv = document.createElement('div');
            leftNodeDiv.className = 'node';
            leftNodeDiv.id = 'node-a';
            const leftNodeLabel = _.get(lhsNode, attributeMap.nodeLabel) || 'Node A';
            const leftNodeIcon = _.get(lhsNode, attributeMap.nodeIcon, '');

            let leftNodeIconSrc;
            if(leftNodeIcon?.startsWith('http')){
                leftNodeIconSrc = leftNodeIcon;
            }else {
                leftNodeIconSrc = iconMap[leftNodeIcon] ? "/" + iconMap[leftNodeIcon] : '/assets/img/blueprints/canvas/empty_icon.png';
            }
            leftNodeDiv.innerHTML = `
                <div class="node-circle">
                    <img src="${leftNodeIconSrc}" />
                </div>
                <div class="node-label">${leftNodeLabel}</div>
            `;
            container.insertBefore(leftNodeDiv, container.querySelector('.edges-container'));
            
            // Create right node (RHS)
            const rightNodeDiv = document.createElement('div');
            rightNodeDiv.className = 'node';
            rightNodeDiv.id = 'node-b';
            const rightNodeLabel = _.get(rhsNode, attributeMap.nodeLabel) || 'Node B';
            const rightNodeIcon = _.get(rhsNode, attributeMap.nodeIcon, '');
            let rightNodeIconSrc;
            if(rightNodeIcon?.startsWith('http')){
                rightNodeIconSrc = rightNodeIcon;
            }else {
                rightNodeIconSrc = iconMap[rightNodeIcon] ? "/" + iconMap[rightNodeIcon] : '/assets/img/blueprints/canvas/empty_icon.png';
            }
            rightNodeDiv.innerHTML = `
                <div class="node-circle">
                    <img src="${rightNodeIconSrc}" />
                </div>
                <div class="node-label">${rightNodeLabel}</div>
            `;
            container.appendChild(rightNodeDiv);

            return  {
                lhsNode,
                rhsNode
            }
        }

        /**
         * Get key value from relationship object
         * First tries _.get() with the key, then searches displayAttributes array
         * Always returns a string (empty string if not found)
         * @param {Object} relationship - The relationship object
         * @param {string} attribute_map_key - The key to search for
         * @returns {string} The value as a string, or empty string if not found
         */
        function getAttributeMapValue(relationship, attribute_map_key) {
            // First try _.get() with the key
            let value = _.get(relationship, attribute_map_key);
            
            // If we got a value (not undefined, null, or empty string), return it as string
            if (value !== undefined && value !== null && value !== '') {
                return String(value);
            }
            
            // If not found, search in displayAttributes array
            if (relationship.displayAttributes && Array.isArray(relationship.displayAttributes)) {
                const displayAttr = relationship.displayAttributes.find(attr => attr.key === attribute_map_key);
                if (displayAttr && displayAttr.value !== undefined && displayAttr.value !== null && displayAttr.value !== '') {
                    return String(displayAttr.value);
                }
            }
            
            return '';
        }

        // Create edges
        function createEdges(relationships) {
            const edgesContainer = document.getElementById('edges');
            
            relationships.forEach((relationship) => {
                // Create edge container
                const edgeDiv = document.createElement('div');
                edgeDiv.className = 'edge';
                if (relationship.dotted) {
                    edgeDiv.classList.add('dotted');
                }

                // Create edge line
                const edgeLine = document.createElement('div');
                edgeLine.className = 'edge-line';

                // Create arrow - determine direction based on relationship's left_id and right_id
                // Compare relationship direction with LHSNodeId (left side) and RHSNodeId (right side)
                // Arrow points right if relationship goes from LHS to RHS
                // Arrow points left if relationship goes from RHS to LHS
                const arrow = document.createElement('div');
                // relationship.left_id = source, relationship.right_id = destination
                // If source is RHS and destination is LHS, arrow points left
                const isRightToLeft = relationship.left_id === RHSNodeId && relationship.right_id === LHSNodeId;
                arrow.className = `arrow ${isRightToLeft ? 'left' : 'right'}`;

                // Create edge label
                const edgeLabel = document.createElement('div');
                edgeLabel.className = 'edge-label';
                edgeLabel.textContent = getAttributeMapValue(relationship, attributeMap.edgeCenterLabel);

                // Get source and destination interface values
                const sourceInterfaceValue = getAttributeMapValue(relationship, attributeMap.edgeSourceLabel);
                const destInterfaceValue = getAttributeMapValue(relationship, attributeMap.edgeDestLabel);

                // Create source interface label - position based on direction
                // If arrow goes right (LHS -> RHS), source is on left
                // If arrow goes left (RHS -> LHS), source is on right
                let sourceInterfaceLabel;
                if(sourceInterfaceValue){
                    sourceInterfaceLabel = document.createElement('p');
                    sourceInterfaceLabel.title = sourceInterfaceValue;
                    sourceInterfaceLabel.className = `interface-label ${isRightToLeft ? 'right' : 'left'}`;
                    sourceInterfaceLabel.textContent = sourceInterfaceValue;
                }

                // Create destination interface label - position based on direction
                // If arrow goes right (LHS -> RHS), destination is on right
                // If arrow goes left (RHS -> LHS), destination is on left
                let destInterfaceLabel;
                if(destInterfaceValue){
                    destInterfaceLabel = document.createElement('p');
                    destInterfaceLabel.title = destInterfaceValue;
                    destInterfaceLabel.className = `interface-label ${isRightToLeft ? 'left' : 'right'}`;
                    destInterfaceLabel.textContent = destInterfaceValue;
                }
                // Assemble edge
                if(!relationship.is_directionless){
                    edgeLine.appendChild(arrow);
                }
                edgeDiv.appendChild(edgeLine);
                edgeDiv.appendChild(edgeLabel);
                if(sourceInterfaceLabel){
                    edgeDiv.appendChild(sourceInterfaceLabel);
                }
                if(destInterfaceLabel){
                    edgeDiv.appendChild(destInterfaceLabel);
                }
                edgesContainer.appendChild(edgeDiv);
            });
        }


        // Initialize the graph
        async function init() {
            if(TEST_MODE){
                LHSNodeId = data.components[0].node_id;
                RHSNodeId = data.components[1].node_id;
                createNodes(data.components);
                createEdges(data.relationships);
                return;
            }
            try {
                const data = await fetchData();
                const relationships = data?.relationships;
                const components = data?.components;

                if (!relationships || relationships?.length === 0) {
                    throw new Error("No data to display");
                    return;
                }

                // filter out edges/relationships
                // Child relationships may have different direction than parent relationship
                // So we need to check both directions: LHS->RHS and RHS->LHS
                // relationship.left_id = source node id, relationship.right_id = destination node id
                const filteredRelationships = relationships.filter(relationship => {
                    // Check if relationship matches parent direction (LHSNodeId -> RHSNodeId)
                    const matchesParentDirection = relationship.left_id === LHSNodeId && relationship.right_id === RHSNodeId;
                    // Check if relationship is in opposite direction (RHSNodeId -> LHSNodeId)
                    const matchesOppositeDirection = relationship.left_id === RHSNodeId && relationship.right_id === LHSNodeId;
                    return matchesParentDirection || matchesOppositeDirection;
                })

                const nodesResult = createNodes(components);
                if (!nodesResult) {
                    throw new Error("LHS or RHS node not found in components");
                }
                const { lhsNode, rhsNode } = nodesResult;
                createEdges(filteredRelationships);

                console.log("MSB data", filteredRelationships, lhsNode, rhsNode)
            } catch (error) {
                console.error("Fetch error:", error);
            }
        }

        // Start the application
        init();
    </script>
</body>
</html>